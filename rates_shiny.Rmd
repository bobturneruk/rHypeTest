---
title: "R Notebook"
output: html_notebook
runtime: shiny
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)

library(tidyverse)
library(broom)

```

#Randomisation
When all parameters including the random seed are kept the same, the simulation results will be the same. This means we can go back to exactly the same simulated data, by remembering the random seed. If we want to re-simulate the data with the rest of the parameters kept constant, the seed can be changed.
```{r}
inputPanel(
  
  numericInput("random_seed", label = "Random seed:",
              value = 1, step = 1)
  
)
```

#Shared parameters

```{r}
inputPanel(
  
  numericInput("n_points", label = "Number of time points:",
              value = 6),
  numericInput("m_points", label = "Number of measurements per time point:",
              value = 5),
  numericInput("sd", label = "Standard deviation of measurements:",
              value = 0.1)
  
)
```

#Case specific parameters

```{r}
inputPanel(

  numericInput("rate_A", label = "Rate (r) of case A:",
              value = -0.3),
  
  numericInput("intercept_A", label = "Intercept (s) of case A:",
              value = 20)
)

inputPanel(
  numericInput("rate_B", label = "Rate (r) of case B:",
              value = -0.5),
  
  numericInput("intercept_B", label = "Intercept (s) of case B:",
              value = 20)
)


```

```{r}

#Simulate data
simulation<-reactive({
  
  relationship<-function(t,rate,intercept){
    #return(intercept+(rate*t)) #linear relationship
    return(intercept*(10^(rate*t))) #power 10 relationship
  }
  
  mn=input$m_points*input$n_points
  
  set.seed(input$random_seed)
  
  
  time_points<-seq(0,input$n_points-1) %>%
    rep(each=input$m_points) 
  
  case<-c(rep("case_A",times=mn),
           rep("case_B",times=mn))
  
  value_A<-relationship(time_points,input$rate_A,input$intercept_A)
  
  value_B<-relationship(time_points,input$rate_B,input$intercept_B)
  
  error<-rnorm(input$n_points*input$m_points*2,sd=input$sd)

  data.frame(time_points=c(time_points,time_points),
             case=case,
             value=c(value_A,value_B),
             error=error,
             value_error=c(value_A,value_B)+error,
             log10_value_error=log10(c(value_A,value_B)+error))
  
})


```

#Plot options

```{r}

inputPanel(

  selectInput("graph_type", "Graph type:",c("Experimental science","Data science")),
  checkboxInput("log_scale", "Log scale:", FALSE)
  
)

```

```{r}
renderPlot({
  
  plot_data<-simulation()
  
  myplot<-ggplot(plot_data,aes(x=time_points,y=value_error,colour=case))
  
  if(input$graph_type=="Experimental science"){
    #Hopefully familiar plot
    myplot<-myplot +
      stat_summary(fun.y = mean, geom = "line") + 
      stat_summary(fun.data = mean_se, geom = "errorbar")
  }
  else
  {
    #Data science style plot
    myplot<-myplot +
      geom_smooth()+
      geom_jitter(width = 0.1)
  }
  
  if(input$log_scale==TRUE){
    myplot<-myplot +
      scale_y_log10()
  }
  
  myplot
  
})
```

$$y=s10^{rt}$$

$$\log_{10}y=\log_{10}(s10^{rt})$$

$$\log_{10}y=\log_{10}s+rt$$

```{r}

renderPrint({
  
  reg_data<-simulation()
  
  reg_data %>%
    lm(formula=log10_value_error~time_points * case, data=.) %>%
      summary()
  
})

```

```{r}

renderPrint({
  
  reg_data<-simulation()
  
  #nls(formula=value_error~(a*10^(b*time_points)) + case, data=reg_data, start=list(a=1,b=1)) %>%
  #  summary()
  
})

```

```{r}

renderTable({
  
  simulation()

},digits = 5)
```

